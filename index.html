<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Truck Drivers Map ‚Äî TruckWork</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <!-- Turf (OSM fill) -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

    <!-- MVT for PTV vector tiles -->
    <script src="https://unpkg.com/leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.js"></script>

    <style>
      html, body, #map { height: 100%; margin: 0; }
      .topbar {
        position: absolute; z-index: 1000; top: 10px; left: 50%; transform: translateX(-50%);
        width: calc(100% - 20px); max-width: 1100px;
        background: rgba(255,255,255,.92); padding: 8px 10px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.1);
        display: grid; grid-template-columns: auto auto 1fr auto; gap: 8px; align-items: center;
        font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      .topbar .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .topbar button { border: 1px solid #ddd; padding: 6px 10px; border-radius: 8px; background: #fff; cursor: pointer; }
      .topbar input[type="number"] { width: 80px; padding: 4px 6px; }
      .checkboxes { display: flex; gap: 10px; flex-wrap: wrap; }
      .checkboxes label { display: flex; align-items: center; gap: 6px; white-space:nowrap; }

      .legend {
        position: absolute; left: 10px; bottom: 10px; z-index: 1000;
        background: rgba(255,255,255,.92); border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.1);
        font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 10px;
      }
      .dot { width: 14px; height: 14px; border-radius: 50%; display: inline-block; border: 2px solid #333; margin-right: 6px; }
      .dot.blue{background:#89b5ff;border-color:#2b6cff;}
      .dot.green{background:#b8f7b1;border-color:#2a7a2a;}
      .dot.orange{background:#ffd3a1;border-color:#c76a00;}
      .dot.gray{background:#e2e2e2;border-color:#666;}
      .dot.red{background:#ffb3b3;border-color:#d70000;}
      .dot.dual{background:linear-gradient(135deg,#b8f7b1 50%,#89b5ff 50%);}
      .dot.dual.shower{box-shadow:0 0 5px 2px #00c3ff;}

      .popup-list{margin:6px 0 0; padding-left:18px;}
      .popup-list li{margin:2px 0;}
      .shield{
        width:22px;height:22px;border-radius:6px;border:2px solid #900;
        background:#fff; display:inline-flex; align-items:center; justify-content:center; font-weight:700;
        color:#900; font-size:12px; line-height:1;
        box-shadow:0 1px 4px rgba(0,0,0,.25);
      }
      .shield.small{width:18px;height:18px;font-size:10px;border-radius:5px;}
    </style>
  </head>

  <body>
    <div id="map"></div>

    <div class="topbar">
      <div class="row">
        <strong>–†–∞–¥–∏—É—Å (–∫–º)</strong>
        <input id="radiusKm" type="number" value="50" min="5" max="300" step="5" />
      </div>

      <div class="row checkboxes">
        <label><input type="checkbox" id="cbTruck" checked /> TIR-–ø–∞—Ä–∫–∏–Ω–≥–∏</label>
        <label><input type="checkbox" id="cbFuel" checked /> –ó–∞–ø—Ä–∞–≤–∫–∏</label>
        <label><input type="checkbox" id="cbMotel" checked /> –ú–æ—Ç–µ–ª–∏</label>
        <label><input type="checkbox" id="cbIndustrial" checked /> –ü—Ä–æ–º–∑–æ–Ω—ã</label>
      </div>

      <div class="row checkboxes">
        <label title="PTV Truck Restrictions"><input type="checkbox" id="cbPTV" checked /> –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è PTV (–ª–∏–Ω–∏–∏+—à–∏–ª–¥—ã)</label>
        <label title="–°–ø–ª–æ—à–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞ –ø–æ OSM"><input type="checkbox" id="cbFill" /> –ó–∞–ª–∏–≤–∫–∞ (OSM)</label>
        <!-- –§–∏–ª—å—Ç—Ä—ã —Ç–∏–ø–æ–≤ -->
        <span>–§–∏–ª—å—Ç—Ä—ã:</span>
        <label><input type="checkbox" class="flt" value="height" checked />–í—ã—Å–æ—Ç–∞</label>
        <label><input type="checkbox" class="flt" value="weight" checked />–ú–∞—Å—Å–∞</label>
        <label><input type="checkbox" class="flt" value="width" checked />–®–∏—Ä–∏–Ω–∞</label>
        <label><input type="checkbox" class="flt" value="length" checked />–î–ª–∏–Ω–∞</label>
        <label><input type="checkbox" class="flt" value="axle" checked />–û—Å–µ–≤–∞—è</label>
        <label><input type="checkbox" class="flt" value="general" checked />–û–±—â–∏–π –∑–∞–ø—Ä–µ—Ç</label>
        <label><input type="checkbox" class="flt" value="trailer" checked />–° –ø—Ä–∏—Ü–µ–ø–æ–º</label>
        <label><input type="checkbox" class="flt" value="delivery" checked />–¢–æ–ª—å–∫–æ –¥–æ—Å—Ç–∞–≤–∫–∞</label>
        <label><input type="checkbox" class="flt" value="hazmat" checked />ADR</label>
        <label><input type="checkbox" class="flt" value="tunnel" checked />–¢—É–Ω–Ω–µ–ª–∏</label>
      </div>

      <div class="row">
        <button id="btnLocate">–ú–æ—ë –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ</button>
        <button id="btnReload">–û–±–Ω–æ–≤–∏—Ç—å</button>
      </div>
    </div>

    <div class="legend">
      <div><span class="dot blue"></span>TIR-–ø–∞—Ä–∫–∏–Ω–≥</div>
      <div><span class="dot dual"></span>–ó–∞–ø—Ä–∞–≤–∫–∞ —Å –ø–∞—Ä–∫–æ–≤–∫–æ–π</div>
      <div><span class="dot dual shower"></span>–ó–∞–ø—Ä–∞–≤–∫–∞ —Å –¥—É—à–µ–º</div>
      <div><span class="dot orange"></span>–ú–æ—Ç–µ–ª—å / –æ—Ç–µ–ª—å</div>
      <div><span class="dot gray"></span>–ü—Ä–æ–º–∑–æ–Ω–∞</div>
      <div><span class="dot red"></span>–ö—Ä–∞—Å–Ω—ã–µ –∑–æ–Ω—ã</div>
    </div>

    <script>
      // ====== BASE MAP ======
      const map = L.map("map", { zoomSnap: 0.5 }).setView([52.23, 21.01], 6);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: "&copy; OpenStreetMap contributors" }).addTo(map);

      // ====== LAYERS ======
      const clusterTruck = L.markerClusterGroup({ disableClusteringAtZoom: 13 });
      const clusterFuel = L.markerClusterGroup({ disableClusteringAtZoom: 13 });
      const clusterMotel = L.markerClusterGroup({ disableClusteringAtZoom: 13 });
      const industrialLayer = L.layerGroup();
      const noGoOSMLayer = L.geoJSON(null, { style: { color: "#d70000", weight: 1, fillColor: "#ff4d4d", fillOpacity: 0.25 } });
      const shieldLayer = L.layerGroup(); // –¥–ª—è –∏–∫–æ–Ω–æ–∫-—à–∏–ª–¥–æ–≤

      [clusterTruck, clusterFuel, clusterMotel, industrialLayer, noGoOSMLayer, shieldLayer].forEach(l => map.addLayer(l));

      // ====== ICONS ======
      const iconTruck = color => L.divIcon({ className: "marker", html:`<span style="display:inline-block;width:16px;height:16px;border-radius:50%;background:${color};border:2px solid #333"></span>`, iconSize:[16,16], iconAnchor:[8,8]});
      const iconDual = shower => L.divIcon({ className: "marker", html:`<span style="display:inline-block;width:16px;height:16px;border-radius:50%;background:linear-gradient(135deg,#b8f7b1 50%,#89b5ff 50%);border:2px solid #333;${shower?'box-shadow:0 0 6px 2px #00c3ff':''}"></span>`, iconSize:[16,16], iconAnchor:[8,8]});
      const shieldIcon = (txt, small=false) => L.divIcon({ className: small?'shield small':'shield', html: txt, iconSize: small?[18,18]:[22,22], iconAnchor: small?[9,9]:[11,11] });

      // ====== HELPERS ======
      const overpass = q => fetch("https://overpass-api.de/api/interpreter?data="+encodeURIComponent(q)).then(r=>r.json());
      const radiusM = () => Math.min(300000, Math.max(5000, +document.getElementById("radiusKm").value*1000));
      const getFilters = () => Array.from(document.querySelectorAll('.flt')).filter(i=>i.checked).map(i=>i.value);

      const popupFromTags = (t, type) => {
        const name = t.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è";
        let s = `<b>${name}</b><br>`;
        if (t.operator) s += `${t.operator}<br>`;
        if (t.brand) s += `–ë—Ä–µ–Ω–¥: ${t.brand}<br>`;
        if (t.amenity === "fuel" && t.shower === "yes") s += "üöø –î—É—à –¥–æ—Å—Ç—É–ø–µ–Ω<br>";
        if (type==="fuel" && t.opening_hours) s += `‚è∞ ${t.opening_hours}<br>`;
        if (t.website) s += `<a href="${t.website}" target="_blank">–°–∞–π—Ç</a>`;
        return s;
      };

      function toLatLng(el) {
        if (el.type === "node") return [el.lat, el.lon];
        if (el.center) return [el.center.lat, el.center.lon];
        return null;
      }

      // ====== OSM LOADERS ======
      async function loadTruck(lat,lon){
        if(!document.getElementById("cbTruck").checked) return;
        clusterTruck.clearLayers();
        const q = `[out:json][timeout:40];
        (node["amenity"="parking"]["parking"="truck"](around:${radiusM()},${lat},${lon});
         way["amenity"="parking"]["parking"="truck"](around:${radiusM()},${lat},${lon});
         node["highway"~"^(services|rest_area)$"](around:${radiusM()},${lat},${lon});
        );out center tags;`;
        const data = await overpass(q);
        (data.elements||[]).forEach(el=>{
          const p = toLatLng(el); if(!p) return;
          const m = L.marker(p,{icon:iconTruck("#89b5ff")}).bindPopup(popupFromTags(el.tags,"truck"));
          clusterTruck.addLayer(m);
        });
      }

      async function loadFuel(lat,lon){
        if(!document.getElementById("cbFuel").checked) return;
        clusterFuel.clearLayers();
        const q = `[out:json][timeout:40];
        (node["amenity"="fuel"](around:${radiusM()},${lat},${lon});
         way["amenity"="fuel"](around:${radiusM()},${lat},${lon});
        );out center tags;`;
        const data = await overpass(q);
        const trucks = clusterTruck.getLayers().map(m=>m.getLatLng());
        (data.elements||[]).forEach(el=>{
          const p = toLatLng(el); if(!p) return;
          const t = el.tags||{};
          const nearTruck = trucks.some(tp => map.distance(tp,p)<150);
          const hasParking = t.parking==="yes"||t["parking:lanes"];
          const hasShower = t.shower==="yes";
          const m = L.marker(p,{icon:iconDual(hasShower)}).bindPopup(popupFromTags(t,"fuel"));
          if(nearTruck||hasParking) clusterFuel.addLayer(m);
        });
      }

      async function loadMotel(lat,lon){
        if(!document.getElementById("cbMotel").checked) return;
        clusterMotel.clearLayers();
        const q = `[out:json][timeout:40];
        (node["tourism"~"^(motel|hotel)$"](around:${radiusM()},${lat},${lon});
         way["tourism"~"^(motel|hotel)$"](around:${radiusM()},${lat},${lon});
        );out center tags;`;
        const data = await overpass(q);
        (data.elements||[]).forEach(el=>{
          const p = toLatLng(el); if(!p) return;
          const m = L.marker(p,{icon:iconTruck("#ffd3a1")}).bindPopup(popupFromTags(el.tags,"motel"));
          clusterMotel.addLayer(m);
        });
      }

      async function loadIndustrial(lat,lon){
        if(!document.getElementById("cbIndustrial").checked) return;
        industrialLayer.clearLayers();
        const q = `[out:json][timeout:40];
        (way["landuse"="industrial"](around:${radiusM()},${lat},${lon});
         relation["landuse"="industrial"](around:${radiusM()},${lat},${lon});
        );out geom;`;
        const data = await overpass(q);
        const trucks = clusterTruck.getLayers().map(m=>m.getLatLng());
        (data.elements||[]).forEach(el=>{
          if(!el.geometry) return;
          const c = el.geometry[Math.floor(el.geometry.length/2)];
          const nearTruck = trucks.some(tp=>map.distance(tp,[c.lat,c.lon])<250);
          if(nearTruck){
            const poly = L.polygon(el.geometry.map(g=>[g.lat,g.lon]),{color:"#666",weight:1,fillColor:"#999",fillOpacity:0.15});
            industrialLayer.addLayer(poly);
          }
        });
      }

      // ====== PTV TRUCK RESTRICTIONS (LINES + CLICKS + SHIELDS) ======
      const PTV_API_KEY = "RVVfZDhhMTljODNhMmYxNGQ2MWEyOGY1NDBmODA3OTIwMDA6OGRlN2YzZTItOTg4Ni00ZGIwLWFjYjAtZGM0ZmJhOGJlOGY4";
      const PTV_URL_TEMPLATE = "https://api.myptv.com/maps/overlays/v1/vector-tiles/{z}/{x}/{y}?layers=truckRestrictions&apiKey="+encodeURIComponent(PTV_API_KEY);
      let ptvLayer = null;

      // —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ restriction_type ‚Üí —Ñ–∏–ª—å—Ç—Ä
      function mapTypeToFilter(rt) {
        // –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
        if (rt === 1) return "height";
        if (rt === 2) return "weight";           // 2 –∏ subtype 1 ‚Äî permitted weight, –æ—Å—Ç–∞–≤–∏–º –ø–æ–¥ weight
        if (rt === 3) return "width";
        if (rt === 4) return "length";
        if (rt === 5) return "axle";
        if (rt === 7) return "length";
        if (rt >= 8 && rt <= 11) return "tunnel";
        if (rt === 12 || rt === 13 || rt === 14) return "hazmat";
        if (rt === 15) return "general";
        if (rt === 16) return "trailer";
        if (rt === 17) return "length";
        if (rt === 18) return "width";
        if (rt === 19 || rt === 20) return "delivery";
        if (rt === -1) return "general"; // combined ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ–≥–¥–∞, –æ—Ç—Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ inner-—Å–æ—Å—Ç–∞–≤—É –Ω–µ–ª—å–∑—è, –æ—Å—Ç–∞–≤–∏–º –∫–∞–∫ –æ–±—â–∏–π
        return "general";
      }

      function ptvLineStyle(props) {
        const cat = props.display_category; // 1..3
        const oneWay = (props.closure_direction === 2 || props.closure_direction === 3);
        const base = cat === 1 ? 5 : (cat === 2 ? 4 : 3);
        return {
          color: "rgba(220,50,80,1)",
          weight: base,
          opacity: 1,
          dashArray: oneWay ? "6,6" : null,
          lineCap: "round",
          lineJoin: "round"
        };
      }

      function humanRestriction(props) {
        let desc = null, times = [];
        try {
          const sd = props.structured_descriptions;
          if (sd && sd.length) {
            desc = sd[0].description || null;
            times = Array.isArray(sd[0].time_domain_descriptions) ? sd[0].time_domain_descriptions : [];
          }
        } catch(_) {}
        if (!desc && props.restriction_type_description) desc = props.restriction_type_description;

        const toM = v => (v!=null ? (v/100).toFixed(2)+" m" : null);
        const toT = v => (v!=null ? (v/1000).toFixed(1)+" t" : null);

        const lines = [];
        if (props.height != null) lines.push("–í—ã—Å–æ—Ç–∞: " + toM(props.height));
        if (props.width != null)  lines.push("–®–∏—Ä–∏–Ω–∞: " + toM(props.width));
        if (props.length != null) lines.push("–î–ª–∏–Ω–∞: " + toM(props.length));
        if (props.weight != null) lines.push("–ú–∞—Å—Å–∞: " + toT(props.weight));
        if (props["permitted weight"] != null) lines.push("–†–∞–∑—Ä–µ—à—ë–Ω–Ω–∞—è –º–∞—Å—Å–∞: " + toT(props["permitted weight"]));
        if (props.axle_load != null) lines.push("–ù–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ –æ—Å—å: " + toT(props.axle_load));
        if (props.number_of_axles != null) lines.push("–ß–∏—Å–ª–æ –æ—Å–µ–π: " + props.number_of_axles);

        let html = `<div style="min-width:240px"><b>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª—è –≥—Ä—É–∑–æ–≤–∏–∫–æ–≤</b>`;
        if (desc) html += `<div>${desc}</div>`;
        if (times.length) html += `<ul class="popup-list">${times.map(t=>`<li>${t}</li>`).join("")}</ul>`;
        if (lines.length) html += `<div style="margin-top:6px">${lines.join("<br>")}</div>`;
        if (props.iso_country_code) html += `<div style="margin-top:6px;opacity:.7">–°—Ç—Ä–∞–Ω–∞: ${props.iso_country_code}</div>`;
        html += `</div>`;
        return html;
      }

      function shieldTextByType(rt) {
        // –ø—Ä–æ—Å—Ç—ã–µ –º–µ—Ç–∫–∏: H (height), Wt, Wd, L, Ax, ADR, T (tunnel), TR (trailer), D (delivery), G (general)
        if (rt === 1) return "H";
        if (rt === 2) return "Wt";
        if (rt === 3) return "Wd";
        if (rt === 4) return "L";
        if (rt === 5) return "Ax";
        if (rt === 7) return "L";
        if (rt >= 8 && rt <= 11) return "T";
        if (rt === 12 || rt === 13 || rt === 14) return "ADR";
        if (rt === 15) return "G";
        if (rt === 16) return "TR";
        if (rt === 17) return "L";
        if (rt === 18) return "Wd";
        if (rt === 19 || rt === 20) return "D";
        if (rt === -1) return "‚Ä¢";
        return "?";
      }

      function addPTVLayer() {
        const filters = new Set(getFilters());
        if (ptvLayer) { map.removeLayer(ptvLayer); ptvLayer = null; }

        ptvLayer = L.vectorGrid.protobuf(PTV_URL_TEMPLATE, {
          interactive: true,
          maxNativeZoom: 18,
          minZoom: 6,
          rendererFactory: L.canvas.tile,
          vectorTileLayerStyles: {
            truckRestrictions: f => {
              // —Ñ–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–ø—É
              const rt = f.properties.restriction_type;
              const group = mapTypeToFilter(rt);
              if (!filters.has(group)) return { opacity: 0 }; // —Å–∫—Ä—ã–≤–∞–µ–º
              return ptvLineStyle(f.properties);
            }
          }
        })
        .on('click', e => {
          const p = e.layer.properties || {};
          // –ø–æ–ø–∞–ø
          L.popup({ maxWidth: 340 }).setLatLng(e.latlng).setContent(humanRestriction(p)).openOn(map);
          // —à–∏–ª–¥ –≤ —Ç–æ—á–∫–µ –∫–ª–∏–∫–∞
          const txt = shieldTextByType(p.restriction_type);
          const m = L.marker(e.latlng, { icon: shieldIcon(txt) }).addTo(shieldLayer);
          // –∞–≤—Ç–æ—É–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 90 —Å–µ–∫., —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–ø–∞–º–∏—Ç—å –∫–∞—Ä—Ç—É
          setTimeout(()=> shieldLayer.removeLayer(m), 90000);
        });

        map.addLayer(ptvLayer);
      }

      function removePTVLayer() {
        if (ptvLayer) { map.removeLayer(ptvLayer); ptvLayer = null; }
        shieldLayer.clearLayers();
      }

      // ====== OSM FILL (—Å–ø–ª–æ—à–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞) ======
      async function loadNoGoFillOSM(lat, lon) {
        noGoOSMLayer.clearLayers();
        const q = `[out:json][timeout:40];
        (
          way["hgv"~"^(no|destination|delivery)$"](around:${radiusM()},${lat},${lon});
          way["access"="no"](around:${radiusM()},${lat},${lon});
          way["motor_vehicle"="no"](around:${radiusM()},${lat},${lon});
          way["maxweight"](around:${radiusM()},${lat},${lon});
          way["maxaxleload"](around:${radiusM()},${lat},${lon});
          way["maxheight"](around:${radiusM()},${lat},${lon});
        );
        out geom tags;`;
        const data = await overpass(q);

        const features = [];
        (data.elements || []).forEach(el => {
          if (!el.geometry) return;
          const isClosed = el.type === "way" &&
            el.geometry.length > 3 &&
            el.geometry[0].lat === el.geometry[el.geometry.length - 1].lat &&
            el.geometry[0].lon === el.geometry[el.geometry.length - 1].lon;

          if (isClosed) {
            const ring = el.geometry.map(g => [g.lon, g.lat]);
            try { features.push(turf.polygon([ring], { d: 1 })); } catch (_) {}
          } else {
            const coords = el.geometry.map(g => [g.lon, g.lat]);
            const line = turf.lineString(coords);
            try {
              const buf = turf.buffer(line, 0.05, { units: "kilometers" }); // ~50 –º
              if (buf) { buf.properties = { d: 1 }; features.push(buf); }
            } catch (_) {}
          }
        });

        if (!features.length) return;
        let dissolved;
        try { dissolved = turf.dissolve(turf.featureCollection(features), { propertyName: "d" }); }
        catch (_) { dissolved = features.reduce((acc, f) => { try { return acc ? turf.union(acc, f) : f; } catch { return acc || f; } }, null); }
        if (!dissolved) return;
        try { dissolved = turf.truncate(dissolved, { precision: 6, coordinates: 2 }); } catch (_){}

        L.geoJSON(dissolved, { style: { color: "#d70000", weight: 1, fillColor: "#ff4d4d", fillOpacity: 0.25 } }).addTo(noGoOSMLayer);
      }

      // ====== LOAD ALL ======
      async function loadAll(lat,lon){
        await loadTruck(lat,lon);
        await loadFuel(lat,lon);
        await loadMotel(lat,lon);
        await loadIndustrial(lat,lon);

        if (document.getElementById("cbPTV").checked) addPTVLayer(); else removePTVLayer();
        if (document.getElementById("cbFill").checked) await loadNoGoFillOSM(lat, lon); else noGoOSMLayer.clearLayers();
      }

      // ====== GEOLOCATION / UI ======
      async function locateUser(){
        if(!navigator.geolocation) return null;
        return new Promise(res=>{
          navigator.geolocation.getCurrentPosition(
            pos=>res({lat:pos.coords.latitude,lon:pos.coords.longitude}),
            ()=>res(null),
            {enableHighAccuracy:true,timeout:8000}
          );
        });
      }

      document.getElementById("btnLocate").onclick = async ()=>{
        const loc = await locateUser();
        if(loc){ map.setView([loc.lat,loc.lon],11); await loadAll(loc.lat,loc.lon);}
        else alert("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é");
      };
      document.getElementById("btnReload").onclick = async ()=>{
        const c = map.getCenter(); await loadAll(c.lat,c.lng);
      };

      // –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–∏
      document.getElementById("cbPTV").addEventListener("change", async ()=>{
        const c = map.getCenter(); await loadAll(c.lat,c.lng);
      });
      document.getElementById("cbFill").addEventListener("change", async ()=>{
        const c = map.getCenter(); await loadAll(c.lat,c.lng);
      });
      document.querySelectorAll(".flt").forEach(cb=>{
        cb.addEventListener("change", ()=>{
          if (document.getElementById("cbPTV").checked) addPTVLayer(); // –ø–µ—Ä–µ—Å—Ç—Ä–æ–∏—Ç—å —Å—Ç–∏–ª—å –ø–æ —Ñ–∏–ª—å—Ç—Ä–∞–º
        });
      });

      // ====== INIT ======
      (async ()=>{
        const c = map.getCenter();
        await loadAll(c.lat,c.lng);
      })();
    </script>
  </body>
</html>
