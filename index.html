<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Truck Drivers Map — TruckWork</title>

  <!-- Leaflet + MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    html, body { height:100%; margin:0; }
    #map { position:fixed; inset:0; }

    .hud {
      position:absolute; z-index:1000; top:10px; left:10px;
      background:rgba(255,255,255,.96); border:1px solid #eee; border-radius:10px;
      padding:8px 10px; font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      box-shadow:0 2px 10px rgba(0,0,0,.08);
      display:flex; align-items:center; gap:8px;
    }
    .hud button {
      border:1px solid #ddd; background:#fff; border-radius:8px; padding:6px 10px; cursor:pointer;
    }
    .hud .dot { width:12px; height:12px; border-radius:50%; display:inline-block; border:2px solid #333; vertical-align:-2px; }
    .dot.service{background:#89b5ff;border-color:#2b6cff;}
    .dot.repair{background:#ffd3a1;border-color:#c76a00;}
    .dot.parking{background:#b8f7b1;border-color:#2a7a2a;}
    .dot.fuel{background:#cde1ff;border-color:#3468ff;}
    .dot.roadpt{background:#ffd1d1;border-color:#d22;}

    .toast {
      position:absolute; left:50%; top:70px; transform:translateX(-50%);
      z-index:1200; background:rgba(255,255,255,.96); border:1px solid #eee; border-radius:10px;
      padding:8px 10px; box-shadow:0 2px 10px rgba(0,0,0,.08); font:13px system-ui;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Tiny HUD: counters + export -->
  <div class="hud">
    <span title="Сервис (OSM)"><span class="dot service"></span> <span id="cntServ">0</span></span>
    <span title="Ремонт (OSM)"><span class="dot repair"></span> <span id="cntRep">0</span></span>
    <span title="Паркинг (MapTrip)"><span class="dot parking"></span> <span id="cntPark">0</span></span>
    <span title="АЗС Diesel (MapTrip)"><span class="dot fuel"></span> <span id="cntFuel">0</span></span>
    <span title="Дорожные работы (точки)"><span class="dot roadpt"></span> <span id="cntRwPt">0</span></span>
    <button id="btnExport">Export JSON</button>
  </div>

  <script>
  /* ===================== CONFIG ===================== */
  const MAPTRIP_TOKEN = "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJzMjQ2NzZAcGp3c3RrLmVkdS5wbCIsImF1dGgiOiJST0xFX1VTRVIiLCJpZCI6MjM0MDAzOCwiY29tcGFueUlkIjoyMzQwMTg2LCJleHAiOjE3NjQyMzE2NDZ9.TseoqPIXt3oTM1DBAR80EuueQA53zjXjCDnsoVCfzqf0syAyquSqIwshzBYLyksEQLTIATHqA0SyGAey0dCtxw";
  const MAPTRIP_BASE  = "https://api.maptrip.de/v1";
  const MT_HEADERS = {
    "Accept": "application/json",
    "Authorization": "Bearer " + MAPTRIP_TOKEN
  };

  const LS_STATE_KEY = "truckwork.map.state.v4";
  const LS_CACHE_KEY = "truckwork.maptrip.cache.v1";

  /* ===================== MAP ===================== */
  const cartoLight = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
    maxZoom: 20, attribution: "© OpenStreetMap & Carto"
  });
  const map = L.map("map", { zoomSnap: .5, layers:[cartoLight] });

  // restore view
  const s = JSON.parse(localStorage.getItem(LS_STATE_KEY) || "{}");
  if (s.center && s.zoom) map.setView(s.center, s.zoom); else map.setView([52.23, 21.01], 10);
  setTimeout(()=>map.invalidateSize(), 50);

  window.addEventListener("beforeunload", ()=>{
    localStorage.setItem(LS_STATE_KEY, JSON.stringify({ center:[map.getCenter().lat, map.getCenter().lng], zoom: map.getZoom() }));
    persistCache();
  });

  /* ===================== LAYERS ===================== */
  const iconDot = cls => L.divIcon({ className:"", html:`<span class="dot ${cls}"></span>`, iconSize:[16,16], iconAnchor:[8,8] });

  const MC_OPTS = { disableClusteringAtZoom: 13, chunkedLoading: true, removeOutsideVisibleBounds: false };
  const clService   = L.markerClusterGroup(MC_OPTS);
  const clRepair    = L.markerClusterGroup(MC_OPTS);
  const clMTparking = L.markerClusterGroup(MC_OPTS);
  const clMTfuel    = L.markerClusterGroup(MC_OPTS);
  const clRwPt      = L.markerClusterGroup({ ...MC_OPTS, disableClusteringAtZoom: 12 });
  const clRwLn      = L.geoJSON(null, { style:()=>({ color:"#d22", weight:3, opacity:.9, dashArray:"6,6" }) });

  [clService, clRepair, clMTparking, clMTfuel, clRwPt, clRwLn].forEach(l=>map.addLayer(l));

  /* ===================== HUD helpers ===================== */
  const $ = id => document.getElementById(id);
  function updateCounts(){
    $("cntServ").textContent = Object.keys(dictOSMserv).length;
    $("cntRep").textContent  = Object.keys(dictOSMrep).length;
    $("cntPark").textContent = Object.keys(cache.parking).length;
    $("cntFuel").textContent = Object.keys(cache.fuel).length;
    $("cntRwPt").textContent = Object.keys(dictRwPts).length;
  }
  function toast(msg, ms=3000){
    const n = document.createElement("div");
    n.className = "toast"; n.textContent = msg;
    document.body.appendChild(n); setTimeout(()=>n.remove(), ms);
  }

  /* ===================== CACHING ===================== */
  // cache of MapTrip features we have ever seen during this session (and from previous sessions)
  const cache = (()=>{
    try { return JSON.parse(localStorage.getItem(LS_CACHE_KEY) || '{"parking":{},"fuel":{}}'); }
    catch { return { parking:{}, fuel:{} }; }
  })();

  function persistCache(){
    try { localStorage.setItem(LS_CACHE_KEY, JSON.stringify(cache)); } catch{}
    updateCounts();
  }

  // export cache to a download JSON
  $("btnExport").onclick = ()=>{
    persistCache();
    const blob = new Blob([JSON.stringify(cache, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `maptrip_cache_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  };

  /* ===================== CORE HELPERS ===================== */
  // MapTrip requires: /{south,west}/{north,east}
  function bboxParamsFromMap(pad = 0){
    const b = map.getBounds().pad(pad);
    const sw = b.getSouthWest(), ne = b.getNorthEast();
    return { south: sw.lat, west: sw.lng, north: ne.lat, east: ne.lng };
  }

  // reconcile markers without flicker
  function reconcileMarkers(cluster, dict, items, getId, toLatLng, toIcon, toPopup){
    const nextIds = new Set();
    for (const it of items){
      const id = getId(it);
      if (!id) continue;
      nextIds.add(id);
      const ll = toLatLng(it);
      if (!ll) continue;
      if (dict[id]) {
        dict[id].setLatLng(ll).setIcon(toIcon(it)).bindPopup(toPopup(it));
      } else {
        const m = L.marker(ll, { icon: toIcon(it) }).bindPopup(toPopup(it));
        dict[id] = m; cluster.addLayer(m);
      }
    }
    for (const id of Object.keys(dict)){
      if (!nextIds.has(id)){
        cluster.removeLayer(dict[id]); delete dict[id];
      }
    }
  }

  /* ===================== OSM LOADERS ===================== */
  async function overpassPOST(query){
    const endpoints = [
      "https://overpass-api.de/api/interpreter",
      "https://overpass.kumi.systems/api/interpreter",
      "https://overpass.nchc.org.tw/api/interpreter"
    ];
    for (const ep of endpoints){
      try{
        const r = await fetch(ep, {
          method:"POST",
          headers:{ "Content-Type":"application/x-www-form-urlencoded; charset=UTF-8" },
          body: "data="+encodeURIComponent(query)
        });
        if (r.ok) return await r.json();
      }catch(_){}
    }
    return { elements:[] };
  }

  const dictOSMserv = {}, dictOSMrep = {};
  async function fetchOSMServicesAndRepair(lat, lon, rad){
    const q = `
      [out:json][timeout:50];
      (
        node["service:vehicle:truck"="yes"](around:${rad},${lat},${lon});
        node["truck:service"="yes"](around:${rad},${lat},${lon});
        node["truck:repair"="yes"](around:${rad},${lat},${lon});
        node["amenity"="car_repair"](around:${rad},${lat},${lon});
        node["shop"="tyres"](around:${rad},${lat},${lon});
        way ["service:vehicle:truck"="yes"](around:${rad},${lat},${lon});
        way ["truck:service"="yes"](around:${rad},${lat},${lon});
        way ["truck:repair"="yes"](around:${rad},${lat},${lon});
        way ["amenity"="car_repair"](around:${rad},${lat},${lon});
        way ["shop"="tyres"](around:${rad},${lat},${lon});
      ); out center tags;`;
    const data = await overpassPOST(q);
    const list = [];
    (data.elements||[]).forEach(el=>{
      const p = el.type==="node" ? [el.lat, el.lon] : (el.center ? [el.center.lat, el.center.lon] : null);
      if (!p) return;
      const [la,lo] = p;
      const t = el.tags||{};
      const isRepair = (t["truck:repair"]==="yes") || /repair|tyre|tire|wulkan|opon/i.test(t.shop||t.amenity||"");
      list.push({
        id: `osm-${el.type}-${el.id}`,
        name: t.name || (isRepair ? "Ремонт/шины" : "Сервис"),
        lat: la, lon: lo,
        addr: [t["addr:street"], t["addr:housenumber"], t["addr:city"]].filter(Boolean).join(", "),
        guess: isRepair ? "repair" : "service"
      });
    });
    return list;
  }

  function popupOSM(it){
    return `<b>${it.name||"Без названия"}</b>${it.addr?("<div>"+it.addr+"</div>"):""}`;
  }

  /* ===================== MAPTRIP LOADERS ===================== */
  // Persistent dicts for current view markers
  const dictMTpark = {};
  const dictMTfuel = {};
  const dictRwPts  = {}; // points from MapTrip DE + OSM nodes (we keep just current view here)

  // add to global cache + return normalized item
  function normalizeAndCache(feature, type){ // type: 'parking'|'fuel'
    const pr = feature.properties || {};
    const [lon,lat] = feature.geometry?.coordinates || [];
    const id = pr.id || `${lat},${lon}`;
    const obj = {
      id, lat, lon,
      name: pr.name || (type==="fuel" ? "АЗС" : "Паркинг"),
      address: pr.address || null,
      brand: pr.brand || null,
      road: pr.road || null,
      spaces: pr.spaces || null,
      occupancy: pr.occupancy || null,
      price: pr.price || null,
      details: pr.details || null,
      provider: pr.provider || null,
      images: pr.images || []
    };
    cache[type][id] = obj;
    return obj;
  }

  function mtPopupParkingObj(o){
    const addr = o.address || {};
    const address = [addr.street, addr.zipcode, addr.city].filter(Boolean).join(", ");
    const occ = o.occupancy ? `<div><small>${o.occupancy}</small></div>` : "";
    const spaces = o.spaces ? `<div>Мест: ${o.spaces}</div>` : "";
    const link = o.details ? `<div><a href="${o.details}" target="_blank" rel="noopener">Подробнее / бронь</a></div>` : "";
    const img = (o.images && o.images[0]) ? `<div style="margin-top:6px"><img src="${o.images[0]}" alt="" style="width:220px;border-radius:8px"/></div>` : "";
    return `<b>${o.name||"Паркинг"}</b>${address?("<div>"+address+"</div>"):""}${spaces}${occ}${link}${img}`;
  }
  function mtPopupFuelObj(o){
    const brand = o.brand ? ` — ${o.brand}` : "";
    const price = (o.price != null) ? `<div><b>Цена:</b> € ${o.price}</div>` : "";
    return `<b>${o.name||"АЗС"}${brand}</b>${price}`;
  }

  async function loadMTparking(){
    const {south,west,north,east} = bboxParamsFromMap(0);
    const url = `${MAPTRIP_BASE}/poi/parking/${south},${west}/${north},${east}`;
    try{
      const r = await fetch(url, { headers: MT_HEADERS });
      if (!r.ok){
        if (r.status===401 || r.status===403) toast("MapTrip: ошибка доступа к парковкам (проверьте токен).");
        return;
      }
      const gj = await r.json();
      const items = (gj.features||[])
        .map(f => {
          const o = normalizeAndCache(f, "parking");
          return { id: "park-"+o.id, lat: o.lat, lon: o.lon, obj: o };
        })
        .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));

      reconcileMarkers(
        clMTparking, dictMTpark, items,
        it => it.id,
        it => [it.lat, it.lon],
        () => iconDot("parking"),
        it => mtPopupParkingObj(it.obj)
      );
      persistCache();
    }catch(e){
      toast("MapTrip: сеть/ошибка парковок.");
    }
  }

  async function loadMTfuel(){
    const {south,west,north,east} = bboxParamsFromMap(0);
    // by requirement — Diesel only
    const url = `${MAPTRIP_BASE}/poi/fuelstations/Diesel/${south},${west}/${north},${east}`;
    try{
      const r = await fetch(url, { headers: MT_HEADERS });
      if (!r.ok){
        if (r.status===401 || r.status===403) toast("MapTrip: ошибка доступа к АЗС (проверьте токен).");
        return;
      }
      const gj = await r.json();
      const items = (gj.features||[])
        .map(f => {
          const o = normalizeAndCache(f, "fuel");
          return { id: "fuel-"+o.id, lat: o.lat, lon: o.lon, obj: o };
        })
        .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));

      reconcileMarkers(
        clMTfuel, dictMTfuel, items,
        it => it.id,
        it => [it.lat, it.lon],
        () => iconDot("fuel"),
        it => mtPopupFuelObj(it.obj)
      );
      persistCache();
    }catch(e){
      toast("MapTrip: сеть/ошибка АЗС.");
    }
  }

  // MapTrip roadworks (DE) — both points and lines
  async function loadMTRoadworks(){
    const {south,west,north,east} = bboxParamsFromMap(0);
    const urlPt = `${MAPTRIP_BASE}/poi/roadworks/points/${south},${west}/${north},${east}`;
    const urlLn = `${MAPTRIP_BASE}/poi/roadworks/lines/${south},${west}/${north},${east}`;

    try{
      // points
      const rp = await fetch(urlPt, { headers: MT_HEADERS });
      if (rp.ok){
        const gj = await rp.json();
        const items = (gj.features||[]).map(f=>{
          const pr = f.properties||{};
          const [lon,lat] = f.geometry?.coordinates||[];
          return { id: pr.id || `${lat},${lon}`, lat, lon, pr };
        }).filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));
        reconcileMarkers(
          clRwPt, dictRwPts, items,
          it=>it.id,
          it=>[it.lat,it.lon],
          ()=>iconDot("roadpt"),
          it=>{
            const pr = it.pr;
            const dates = [pr.startDate, pr.endDate].filter(Boolean).join(" → ");
            const len   = pr.length ? `, ~${(pr.length/1000).toFixed(2)} км` : "";
            const speed = pr.speedLimit ? `, ${pr.speedLimit} км/ч` : "";
            return `<b>${pr.type||"Road works"} ${pr.road?("— "+pr.road):""}</b>
              ${pr.startName||pr.start?("<div>"+(pr.startName||pr.start)+" → "+(pr.endName||pr.end||"")+"</div>"):""}
              ${dates?("<div>"+dates+len+speed+"</div>"):""}
              ${pr.description?('<div style="margin-top:6px">'+pr.description+'</div>'):""}`;
          }
        );
      }
      // lines
      const rl = await fetch(urlLn, { headers: MT_HEADERS });
      clRwLn.clearLayers();
      if (rl.ok){
        const gj2 = await rl.json();
        clRwLn.addData(gj2).eachLayer(l=>l.bindPopup((() => {
          const pr = l.feature.properties || {};
          const dates = [pr.startDate, pr.endDate].filter(Boolean).join(" → ");
          const len   = pr.length ? `, ~${(pr.length/1000).toFixed(2)} км` : "";
          const speed = pr.speedLimit ? `, ${pr.speedLimit} км/ч` : "";
          return `<b>${pr.type||"Road works"} ${pr.road?("— "+pr.road):""}</b>
            ${pr.startName||pr.start?("<div>"+(pr.startName||pr.start)+" → "+(pr.endName||pr.end||"")+"</div>"):""}
            ${dates?("<div>"+dates+len+speed+"</div>"):""}
            ${pr.description?('<div style="margin-top:6px">'+pr.description+'</div>'):""}`;
        })()));
      }
    }catch(_){}
  }

  /* ===================== OSM ROADWORKS fallback ===================== */
  async function loadOSMRoadworks(){
    // lightweight hint layer anywhere in EU/world (construction features)
    const c = map.getCenter(), rad = 50000;
    const q = `
      [out:json][timeout:50];
      (
        way["highway"="construction"](around:${rad},${c.lat},${c.lng});
        node["highway"="construction"](around:${rad},${c.lat},${c.lng});
      );
      out geom tags;`;
    const d = await overpassPOST(q);
    // Only draw nodes as red points (we keep line layer to MapTrip DE)
    const pts = [];
    (d.elements||[]).forEach(el=>{
      if (el.type==="node"){
        pts.push({ id:"osmrwp-"+el.id, lat:el.lat, lon:el.lon, pr:{ type:"ConstructionWorks", road: el.tags?.ref || el.tags?.name || "" }});
      }
    });
    reconcileMarkers(
      clRwPt, dictRwPts, pts,
      it=>it.id,
      it=>[it.lat,it.lon],
      ()=>iconDot("roadpt"),
      it=>`<b>${it.pr.type}</b> ${it.pr.road?("— "+it.pr.road):""}`
    );
  }

  /* ===================== MASTER LOAD & EVENTS ===================== */
  async function loadOSMLocal(){
    const c = map.getCenter(), rad = Math.min(500000, Math.max(5000, 50*1000)); // 50km default
    const osmItems = await fetchOSMServicesAndRepair(c.lat, c.lng, rad);
    const serv = osmItems.filter(x => x.guess !== "repair");
    const rep  = osmItems.filter(x => x.guess === "repair");

    reconcileMarkers(
      clService, dictOSMserv, serv,
      it => it.id,
      it => [it.lat, it.lon],
      ()  => iconDot("service"),
      it => popupOSM(it)
    );
    reconcileMarkers(
      clRepair, dictOSMrep, rep,
      it => it.id,
      it => [it.lat, it.lon],
      ()  => iconDot("repair"),
      it => popupOSM(it)
    );
  }

  async function loadAll(){
    // base OSM (always)
    await loadOSMLocal();

    // MapTrip (fuel/parking/roadworks DE)
    await Promise.all([
      loadMTparking(),
      loadMTfuel(),
      (async ()=>{ await loadMTRoadworks(); await loadOSMRoadworks(); })()
    ]);

    updateCounts();
  }

  // Throttled updates
  let moveTimer = null;
  map.on("moveend zoomend", ()=>{
    if (moveTimer) clearTimeout(moveTimer);
    moveTimer = setTimeout(loadAll, 450);
    // persist view
    localStorage.setItem(LS_STATE_KEY, JSON.stringify({ center:[map.getCenter().lat, map.getCenter().lng], zoom: map.getZoom() }));
  });

  // initial load
  (async ()=>{ await loadAll(); })();

  // tiny flicker fix for clusters at tile seams
  const originalProject = map.options.crs.project;
  map.options.crs.project = function (latlng) {
    const p = originalProject.call(this, latlng);
    p.x += 0.0000001; p.y += 0.0000001;
    return p;
  };
  </script>
</body>
</html>
