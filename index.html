<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Truck Drivers Map ‚Äî TruckWork</title>

    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

    <style>
      html, body, #map { height: 100%; margin: 0; }

      .topbar {
        position: absolute;
        z-index: 1000;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 20px);
        max-width: 980px;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px 10px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      .topbar button { border: 1px solid #ddd; padding: 6px 10px; border-radius: 8px; background: #fff; cursor: pointer; }
      .topbar input[type="number"] { width: 80px; padding: 4px 6px; }
      .checkboxes { display: flex; gap: 10px; flex-wrap: wrap; }
      .checkboxes label { display: flex; align-items: center; gap: 6px; }

      .legend {
        position: absolute;
        left: 10px;
        bottom: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.92);
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        padding: 10px;
      }
      .dot { width: 14px; height: 14px; border-radius: 50%; display: inline-block; border: 2px solid #333; margin-right: 6px; }
      .dot.blue{background:#89b5ff;border-color:#2b6cff;}
      .dot.green{background:#b8f7b1;border-color:#2a7a2a;}
      .dot.orange{background:#ffd3a1;border-color:#c76a00;}
      .dot.gray{background:#e2e2e2;border-color:#666;}
      .dot.red{background:#ffb3b3;border-color:#d70000;}
      .dot.dual {
        background: linear-gradient(135deg, #b8f7b1 50%, #89b5ff 50%);
      }
      .dot.dual.shower {
        box-shadow: 0 0 5px 2px #00c3ff;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>

    <div class="topbar">
      <strong>–†–∞–¥–∏—É—Å (–∫–º)</strong>
      <input id="radiusKm" type="number" value="50" min="5" max="300" step="5" />
      <div class="checkboxes">
        <label><input type="checkbox" id="cbTruck" checked /> TIR-–ø–∞—Ä–∫–∏–Ω–≥–∏</label>
        <label><input type="checkbox" id="cbFuel" checked /> –ó–∞–ø—Ä–∞–≤–∫–∏</label>
        <label><input type="checkbox" id="cbMotel" checked /> –ú–æ—Ç–µ–ª–∏</label>
        <label><input type="checkbox" id="cbIndustrial" checked /> –ü—Ä–æ–º–∑–æ–Ω—ã</label>
        <label><input type="checkbox" id="cbNoGo" checked /> –ö—Ä–∞—Å–Ω—ã–µ –∑–æ–Ω—ã</label>
      </div>
      <button id="btnLocate">–ú–æ—ë –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ</button>
      <button id="btnReload">–û–±–Ω–æ–≤–∏—Ç—å</button>
    </div>

    <div class="legend">
      <div><span class="dot blue"></span>TIR-–ø–∞—Ä–∫–∏–Ω–≥</div>
      <div><span class="dot dual"></span>–ó–∞–ø—Ä–∞–≤–∫–∞ —Å –ø–∞—Ä–∫–æ–≤–∫–æ–π</div>
      <div><span class="dot dual shower"></span>–ó–∞–ø—Ä–∞–≤–∫–∞ —Å –¥—É—à–µ–º</div>
      <div><span class="dot orange"></span>–ú–æ—Ç–µ–ª—å / –æ—Ç–µ–ª—å</div>
      <div><span class="dot gray"></span>–ü—Ä–æ–º–∑–æ–Ω–∞</div>
      <div><span class="dot red"></span>–ö—Ä–∞—Å–Ω–∞—è –∑–æ–Ω–∞</div>
    </div>

    <script>
      const map = L.map("map", { zoomSnap: 0.5 }).setView([52.23, 21.01], 6);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 18,
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);

      // === LAYERS ===
      const clusterTruck = L.markerClusterGroup({ disableClusteringAtZoom: 13 });
      const clusterFuel = L.markerClusterGroup({ disableClusteringAtZoom: 13 });
      const clusterMotel = L.markerClusterGroup({ disableClusteringAtZoom: 13 });
      const industrialLayer = L.layerGroup();
      const noGoLayer = L.geoJSON(null, { style: { color: "#d70000", weight: 2, fillColor: "#ff4d4d", fillOpacity: 0.25 } });

      [clusterTruck, clusterFuel, clusterMotel, industrialLayer, noGoLayer].forEach(l => map.addLayer(l));

      // === ICONS ===
      const iconTruck = color => L.divIcon({ className: "marker", html:`<span style="display:inline-block;width:16px;height:16px;border-radius:50%;background:${color};border:2px solid #333"></span>`, iconSize:[16,16], iconAnchor:[8,8]});
      const iconDual = shower => L.divIcon({ className: "marker", html:`<span style="display:inline-block;width:16px;height:16px;border-radius:50%;background:linear-gradient(135deg,#b8f7b1 50%,#89b5ff 50%);border:2px solid #333;${shower?'box-shadow:0 0 6px 2px #00c3ff':''}"></span>`, iconSize:[16,16], iconAnchor:[8,8]});

      // === HELPERS ===
      const overpass = q => fetch("https://overpass-api.de/api/interpreter?data="+encodeURIComponent(q)).then(r=>r.json());
      const radiusM = () => Math.min(300000, Math.max(5000, +document.getElementById("radiusKm").value*1000));

      const popupFromTags = (t, type) => {
        const name = t.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è";
        let s = `<b>${name}</b><br>`;
        if (t.operator) s += `${t.operator}<br>`;
        if (t.brand) s += `–ë—Ä–µ–Ω–¥: ${t.brand}<br>`;
        if (t.amenity === "fuel" && t.shower === "yes") s += "üöø –î—É—à –¥–æ—Å—Ç—É–ø–µ–Ω<br>";
        if (type==="fuel" && t.opening_hours) s += `‚è∞ ${t.opening_hours}<br>`;
        if (t.website) s += `<a href="${t.website}" target="_blank">–°–∞–π—Ç</a>`;
        return s;
      };

      function toLatLng(el) {
        if (el.type === "node") return [el.lat, el.lon];
        if (el.center) return [el.center.lat, el.center.lon];
        return null;
      }

      // === LOADERS ===
      async function loadTruck(lat,lon){
        if(!document.getElementById("cbTruck").checked) return;
        clusterTruck.clearLayers();
        const q = `[out:json][timeout:40];
        (node["amenity"="parking"]["parking"="truck"](around:${radiusM()},${lat},${lon});
         way["amenity"="parking"]["parking"="truck"](around:${radiusM()},${lat},${lon});
         node["highway"~"^(services|rest_area)$"](around:${radiusM()},${lat},${lon});
        );out center tags;`;
        const data = await overpass(q);
        data.elements.forEach(el=>{
          const p = toLatLng(el);
          if(!p) return;
          const m = L.marker(p,{icon:iconTruck("#89b5ff")}).bindPopup(popupFromTags(el.tags,"truck"));
          clusterTruck.addLayer(m);
        });
      }

      async function loadFuel(lat,lon){
        if(!document.getElementById("cbFuel").checked) return;
        clusterFuel.clearLayers();
        const q = `[out:json][timeout:40];
        (node["amenity"="fuel"](around:${radiusM()},${lat},${lon});
         way["amenity"="fuel"](around:${radiusM()},${lat},${lon});
        );out center tags;`;
        const data = await overpass(q);
        const trucks = clusterTruck.getLayers().map(m=>m.getLatLng());
        data.elements.forEach(el=>{
          const p = toLatLng(el); if(!p) return;
          const t = el.tags||{};
          const nearTruck = trucks.some(tp => map.distance(tp,p)<150);
          const hasParking = t.parking==="yes"||t["parking:lanes"];
          const hasShower = t.shower==="yes";
          const m = L.marker(p,{icon:iconDual(hasShower)}).bindPopup(popupFromTags(t,"fuel"));
          if(nearTruck||hasParking) clusterFuel.addLayer(m);
        });
      }

      async function loadMotel(lat,lon){
        if(!document.getElementById("cbMotel").checked) return;
        clusterMotel.clearLayers();
        const q = `[out:json][timeout:40];
        (node["tourism"~"^(motel|hotel)$"](around:${radiusM()},${lat},${lon});
         way["tourism"~"^(motel|hotel)$"](around:${radiusM()},${lat},${lon});
        );out center tags;`;
        const data = await overpass(q);
        data.elements.forEach(el=>{
          const p = toLatLng(el); if(!p) return;
          const m = L.marker(p,{icon:iconTruck("#ffd3a1")}).bindPopup(popupFromTags(el.tags,"motel"));
          clusterMotel.addLayer(m);
        });
      }

      async function loadIndustrial(lat,lon){
        if(!document.getElementById("cbIndustrial").checked) return;
        industrialLayer.clearLayers();
        const q = `[out:json][timeout:40];
        (way["landuse"="industrial"](around:${radiusM()},${lat},${lon});
         relation["landuse"="industrial"](around:${radiusM()},${lat},${lon});
        );out geom;`;
        const data = await overpass(q);
        const trucks = clusterTruck.getLayers().map(m=>m.getLatLng());
        data.elements.forEach(el=>{
          if(!el.geometry) return;
          const c = el.geometry[Math.floor(el.geometry.length/2)];
          const nearTruck = trucks.some(tp=>map.distance(tp,[c.lat,c.lon])<250);
          if(nearTruck){
            const poly = L.polygon(el.geometry.map(g=>[g.lat,g.lon]),{color:"#666",weight:1,fillColor:"#999",fillOpacity:0.15});
            industrialLayer.addLayer(poly);
          }
        });
      }

      async function loadNoGo(lat, lon) {
        if (!document.getElementById("cbNoGo").checked) return;
        noGoLayer.clearLayers();
      
        const q = `[out:json][timeout:40];
        (
          way["hgv"~"^(no|destination|delivery)$"](around:${radiusM()},${lat},${lon});
          way["access"="no"](around:${radiusM()},${lat},${lon});
          way["motor_vehicle"="no"](around:${radiusM()},${lat},${lon});
          way["maxweight"](around:${radiusM()},${lat},${lon});        // –≤–µ—Å–æ–≤—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
          way["maxaxleload"](around:${radiusM()},${lat},${lon});
          way["maxheight"](around:${radiusM()},${lat},${lon});        // –≥–∞–±–∞—Ä–∏—Ç—ã (–º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å –ø–æ –∂–µ–ª–∞–Ω–∏—é)
          // –µ—Å–ª–∏ –≥–¥–µ-—Ç–æ —Ä–∞–∑–º–µ—á–µ–Ω—ã –∑–æ–Ω—ã:
          relation["zone:hgv"](around:${radiusM()},${lat},${lon});
          relation["access"="no"](around:${radiusM()},${lat},${lon});
        );
        out geom tags;`;
      
        const data = await overpass(q);
      
        // 1) —Å–æ–±–∏—Ä–∞–µ–º –±—É—Ñ–µ—Ä—ã –¥–ª—è –ª–∏–Ω–∏–π –∏ –ø–æ–ª–∏–≥–æ–Ω—ã –∫–∞–∫ –µ—Å—Ç—å
        const features = [];
      
        (data.elements || []).forEach(el => {
          if (!el.geometry) return;
      
          // –î–ª—è –∑–∞–º–∫–Ω—É—Ç—ã—Ö ways —Å –ø–ª–æ—â–∞–¥—å—é ‚Äî —Å—Ä–∞–∑—É –¥–µ–ª–∞–µ–º Polygon
          const isClosed = el.type === "way" &&
                           el.geometry.length > 3 &&
                           el.geometry[0].lat === el.geometry[el.geometry.length - 1].lat &&
                           el.geometry[0].lon === el.geometry[el.geometry.length - 1].lon;
      
          if (isClosed) {
            const ring = el.geometry.map(g => [g.lon, g.lat]);
            try {
              features.push(turf.polygon([ring], { d: 1 }));
            } catch (_) {}
            return;
          }
      
          // –ò–Ω–∞—á–µ ‚Äî —ç—Ç–æ –ª–∏–Ω–µ–π–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è: –±—É—Ñ–µ—Ä–∏–º –ª–∏–Ω–∏—é
          const coords = el.geometry.map(g => [g.lon, g.lat]);
          const line = turf.lineString(coords);
          try {
            // —à–∏—Ä–∏–Ω—É –±—É—Ñ–µ—Ä–∞ –º–æ–∂–µ—à—å –ø–æ–¥–ø—Ä–∞–≤–∏—Ç—å (—Å–µ–π—á–∞—Å 50 –º)
            const buf = turf.buffer(line, 0.05, { units: "kilometers" });
            if (buf) {
              // —Å—Ç–∞–≤–∏–º –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ ‚Äî –Ω—É–∂–Ω–æ –¥–ª—è dissolve
              buf.properties = { d: 1 };
              features.push(buf);
            }
          } catch (_) {}
        });
      
        if (!features.length) return;
      
        // 2) Dissolve: –æ–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å—ë –≤ –æ–¥–Ω—É (multi)–ø–æ–ª–∏–≥–æ–Ω–∞–ª—å–Ω—É—é –≥–µ–æ–º–µ—Ç—Ä–∏—é
        let dissolved;
        try {
          const fc = turf.featureCollection(features);
          // dissolve –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é —Å–≤–æ–π—Å—Ç–≤–∞; —É –Ω–∞—Å —É –≤—Å–µ—Ö d=1
          dissolved = turf.dissolve(fc, { propertyName: "d" });
        } catch (e) {
          // fallback: –ø–æ–ø–∞—Ä–Ω—ã–π union, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ —É CDN-–≤–µ—Ä—Å–∏–∏ –Ω–µ—Ç dissolve
          dissolved = features.reduce((acc, f) => {
            try { return acc ? turf.union(acc, f) : f; } catch (_) { return acc || f; }
          }, null);
        }
      
        if (!dissolved) return;
      
        // 3) (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) —á—É—Ç—å —É–ø—Ä–æ—â–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é, —á—Ç–æ–±—ã —Ä–µ–Ω–¥–µ—Ä –Ω–µ –∑–∞–¥—ã—Ö–∞–ª—Å—è
        try {
          dissolved = turf.truncate(dissolved, { precision: 6, coordinates: 2 });
        } catch (_) {}
      
        // 4) –†–∏—Å—É–µ–º –û–î–ù–û–ô —Å–ø–ª–æ—à–Ω–æ–π —Ñ–∏–≥—É—Ä–æ–π
        L.geoJSON(dissolved, {
          style: { color: "#d70000", weight: 1, fillColor: "#ff4d4d", fillOpacity: 0.25 }
        }).addTo(noGoLayer);
      }


      async function loadAll(lat,lon){
        await loadTruck(lat,lon);
        await loadFuel(lat,lon);
        await loadMotel(lat,lon);
        await loadIndustrial(lat,lon);
        await loadNoGo(lat,lon);
      }

      async function locateUser(){
        if(!navigator.geolocation) return null;
        return new Promise(res=>{
          navigator.geolocation.getCurrentPosition(
            pos=>res({lat:pos.coords.latitude,lon:pos.coords.longitude}),
            ()=>res(null),
            {enableHighAccuracy:true,timeout:8000}
          );
        });
      }

      document.getElementById("btnLocate").onclick = async ()=>{
        const loc = await locateUser();
        if(loc){ map.setView([loc.lat,loc.lon],11); await loadAll(loc.lat,loc.lon);}
        else alert("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é");
      };
      document.getElementById("btnReload").onclick = async ()=>{
        const c = map.getCenter(); await loadAll(c.lat,c.lng);
      };

      // –ü–µ—Ä–≤–∏—á–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
      (async ()=>{
        const c = map.getCenter();
        await loadAll(c.lat,c.lng);
      })();
    </script>
  </body>
</html>
